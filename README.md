# 12.6 Репликация и масштабирование. Часть 2.

### Задание 1.

Опишите основные преимущества использования масштабирования методами:

- активный master-сервер и пассивный репликационный slave-сервер; 
- master-сервер и несколько slave-серверов;


*Дайте ответ в свободной форме.*

#### *Ответ:*
1. Активный master‑сервер и пассивный slave‑сервер
Основные преимущества:
Отказоустойчивость — при падении master‑сервера можно быстро переключиться на slave.
Простота настройки — минимальная конфигурация, легко администрировать.
Низкая нагрузка на сеть — одна реплика, минимум трафика репликации.
Сохранность данных — slave‑сервер всегда имеет актуальную копию (с небольшой задержкой).
Экономия ресурсов — не требуется много серверов и лицензий.

2. Master‑сервер и несколько slave‑серверов
Основные преимущества:
Высокая доступность — выход из строя одного slave не влияет на систему; возможен failover на любой из оставшихся.
Распределение нагрузки — чтение можно направлять на разные slave‑серверы, снижая нагрузку на master.
Географическое распределение — slave‑серверы можно разместить в разных регионах для локального доступа.
Резервирование — несколько копий данных повышают надёжность хранения.
Гибкость эксплуатации — можно временно отключать отдельные slave для обслуживания без остановки системы.
Масштабируемость чтения — добавление новых slave позволяет наращивать производительность при росте числа запросов на чтение.

### Задание 2.


#### *Ответ:*
1. Принципы и Концепции
Вертикальный шардинг — это разделение таблиц по функциональным доменам и размещение их на разных серверах. Мы будем использовать его как первый шаг.
Горизонтальный шардинг — это разделение данных одной таблицы по разным серверам на основе определенного ключа (шард-ключа). Мы применим его к таблицам, которые слишком велики для одного сервера.

Ключевые цели:
Масштабируемость: Возможность добавлять новые серверы для обработки растущей нагрузки.
Производительность: Изоляция нагрузки (чтение/запись) на разные серверы.
Доступность: Отказ одного сервера не должен выводить из строя всю систему.

2. План Шардинга
Шаг 1: Вертикальный Шардинг (Разделение по доменам)
Разделим исходную базу данных на три логические части, каждую на своем сервере.
Шард UserDB: Содержит только таблицу пользователи.
Шард BookDB: Содержит только таблицу книги.
Шард ShopDB: Содержит только таблицу магазины.

Принцип разграничения: Каждый шард отвечает за свой независимый бизнес-объект. Запросы к пользователям идут на один сервер, к книгам — на другой, и т.д.

Шаг 2: Горизонтальный Шардинг (Внутри каждого домена)
Теперь разделим данные внутри каждого из этих шардов.
Шардирование UserDB (таблица пользователи):
Ключ шардирования: user_id (ID пользователя).

Стратегия: Хэш-функция от user_id по модулю N (где N — количество шардов). Например, user_id % 4 определит, на каком из 4-х физических шардов лежат данные пользователя.
Результат: UserDB_Shard0, UserDB_Shard1, ..., UserDB_ShardN.

Шардирование BookDB (таблица книги):

Ключ шардирования: book_id (ID книги).
Стратегия: Аналогично, хэш от book_id. Это обеспечивает равномерное распределение книг по шардам.

Результат: BookDB_Shard0, BookDB_Shard1, ..., BookDB_ShardN.
Шардирование ShopDB (таблица магазины):
Ключ шардирования: shop_id (ID магазина) или region (регион).

Стратегия:
Если используется shop_id — хэширование, как для пользователей.
Если используется region — диапазонное шардирование. Например, магазины из Москвы в ShopDB_Region_Msk, из СПб — в ShopDB_Region_Spb. Это географически локализует данные.
Результат: ShopDB_Shard0, ... или ShopDB_Region_Msk, ShopDB_Region_Spb, ...
```
+----------------------------------------------------------------------------------+
|                               КЛИЕНТСКОЕ ПРИЛОЖЕНИЕ (API)                        |
|                                                                                  |
|  +---------------------------+                                                   |
|  | Логика приложения         |                                                   |
|  | - Формирует SQL-запросы   |                                                   |
|  +---------------------------+                                                   |
+------------------------------------------+---------------------------------------+
                                           |
                              (Все запросы идут через роутер)
                                           |
+------------------------------------------v--------------------------------------+
|                             ШАРД-РОУТЕР / ROUTER                                |
|                                                                                 |
| Функции:                                                                        |
| 1. Анализ SQL-запроса                                                           |
| 2. Определение целевого вертикального шарда                                     |
| 3. Вычисление ключа шардирования (user_id, book_id, shop_id)                    |
| 4. Определение целевого горизонтального шарда                                   |
| 5. Перенаправление запроса на нужный сервер БД                                  |
+---------------------------------------------------------------------------------+
                                           |
           +-------------------------------+---------------------------+
           |                               |                           |
           v                               v                           v
+----------------------+      +----------------------+      +----------------------+
| ВЕРТИКАЛЬНЫЙ ШАРД:   |      |  ВЕРТИКАЛЬНЫЙ ШАРД:  |      |  ВЕРТИКАЛЬНЫЙ ШАРД:  |
|       USERDB         |      |       BOOKDB         |      |       SHOPDB         |
|                      |      |                      |      |                      |
| Таблица: пользователи|      | Таблица: книги       |      | Таблица: магазины    |
+----------------------+      +----------------------+      +----------------------+
           |                               |                   |
           |                               |                   |
  +--------+--------+             +--------+--------+    +-----+-----+-----+
  |        |        |             |        |        |    |     |     |     |
  v        v        v             v        v        v    v     v     v     v
+---+    +---+    +---+         +---+    +---+    +---+ +---+ +---+ +---+ +---+
|U0 |    |U1 |    |U2 |   ...   |B0 |    |B1 |    |B2 | |S0 | |S1 | |S2 | |S3 |
+---+    +---+    +---+         +---+    +---+    +---+ +---+ +---+ +---+ +---+
|M|R|    |M|R|    |M|R|         |M|R|    |M|R|    |M|R| |M|R| |M|R| |M|R| |M|R|
+---+    +---+    +---+         +---+    +---+    +---+ +---+ +---+ +---+ +---+
```
Пояснение к блок-схеме:
Шард-роутер — это центральный мозг системы. Он знает схему шардирования и перенаправляет SQL-запросы к нужному физическому серверу.
Вертикальные шарды — это логические группы, разделенные по типу данных.
Горизонтальные шарды — это физические серверы баз данных, которые хранят части данных одной таблицы.

4. Режимы работы серверов
Для обеспечения отказоустойчивости каждый физический шард должен работать в режиме Мастер-Реплика (Master-Replica).

Мастер (Master):
Принимает все операции записи (INSERT, UPDATE, DELETE) для своего сегмента данных.
Асинхронно или синхронно реплицирует изменения на свою реплику.
Может принимать операции чтения, но обычно нагрузка чтения переносится на реплики.

Реплика (Replica):
Принимает данные только с Мастера. Запись напрямую в реплику невозможна.
Используется только для операций чтения (SELECT).
Служит "горячим" резервом: в случае падения Мастера, одна из Реплик может быть быстро повышена до роли нового Мастера (процесс называется failover).

Пример для UserDB_Shard0:
UserDB_Shard0_Master (в Москве) — принимает запись.
UserDB_Shard0_Replica1 (в Москве) — принимает чтение для балансировки нагрузки.
UserDB_Shard0_Replica2 (в СПб) — принимает чтение и служит гео-резервной копией.
